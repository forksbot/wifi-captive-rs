// This code was autogenerated with `dbus-codegen-rust -c nonblock -m None --dbuscrate ::dbus -o device.rs`, see https://github.com/diwic/dbus-rs
use ::dbus;
use ::dbus::arg;
use ::dbus::nonblock;

pub trait NetConnmanIwdDevice {
    fn name(&self) -> nonblock::MethodReply<String>;
    fn address(&self) -> nonblock::MethodReply<String>;
    fn wds(&self) -> nonblock::MethodReply<bool>;
    fn set_wds(&self, value: bool) -> nonblock::MethodReply<()>;
    fn powered(&self) -> nonblock::MethodReply<bool>;
    fn set_powered(&self, value: bool) -> nonblock::MethodReply<()>;
    fn adapter(&self) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn mode(&self) -> nonblock::MethodReply<String>;
    fn set_mode(&self, value: String) -> nonblock::MethodReply<()>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> NetConnmanIwdDevice for nonblock::Proxy<'a, C> {
    fn name(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "net.connman.iwd.Device", "Name")
    }

    fn address(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "net.connman.iwd.Device", "Address")
    }

    fn wds(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "net.connman.iwd.Device", "WDS")
    }

    fn powered(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "net.connman.iwd.Device", "Powered")
    }

    fn adapter(&self) -> nonblock::MethodReply<dbus::Path<'static>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "net.connman.iwd.Device", "Adapter")
    }

    fn mode(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "net.connman.iwd.Device", "Mode")
    }

    fn set_wds(&self, value: bool) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "net.connman.iwd.Device",
            "WDS",
            value,
        )
    }

    fn set_powered(&self, value: bool) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "net.connman.iwd.Device",
            "Powered",
            value,
        )
    }

    fn set_mode(&self, value: String) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "net.connman.iwd.Device",
            "Mode",
            value,
        )
    }
}

pub trait NetConnmanIwdStation {
    fn connect_hidden_network(&self, name: &str) -> nonblock::MethodReply<()>;
    fn disconnect(&self) -> nonblock::MethodReply<()>;
    fn get_ordered_networks(&self) -> nonblock::MethodReply<Vec<(dbus::Path<'static>, i16)>>;
    fn get_hidden_access_points(&self) -> nonblock::MethodReply<Vec<(String, i16, String)>>;
    fn scan(&self) -> nonblock::MethodReply<()>;
    fn register_signal_level_agent(&self, path: dbus::Path, levels: Vec<i16>) -> nonblock::MethodReply<()>;
    fn unregister_signal_level_agent(&self, path: dbus::Path) -> nonblock::MethodReply<()>;
    fn connected_network(&self) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn scanning(&self) -> nonblock::MethodReply<bool>;
    fn state(&self) -> nonblock::MethodReply<String>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> NetConnmanIwdStation for nonblock::Proxy<'a, C> {
    fn connect_hidden_network(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Station", "ConnectHiddenNetwork", (name,))
    }

    fn disconnect(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Station", "Disconnect", ())
    }

    fn get_ordered_networks(&self) -> nonblock::MethodReply<Vec<(dbus::Path<'static>, i16)>> {
        self.method_call("net.connman.iwd.Station", "GetOrderedNetworks", ())
            .and_then(|r: (Vec<(dbus::Path<'static>, i16)>,)| Ok(r.0))
    }

    fn get_hidden_access_points(&self) -> nonblock::MethodReply<Vec<(String, i16, String)>> {
        self.method_call("net.connman.iwd.Station", "GetHiddenAccessPoints", ())
            .and_then(|r: (Vec<(String, i16, String)>,)| Ok(r.0))
    }

    fn scan(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Station", "Scan", ())
    }

    fn register_signal_level_agent(&self, path: dbus::Path, levels: Vec<i16>) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Station", "RegisterSignalLevelAgent", (path, levels))
    }

    fn unregister_signal_level_agent(&self, path: dbus::Path) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Station", "UnregisterSignalLevelAgent", (path,))
    }

    fn connected_network(&self) -> nonblock::MethodReply<dbus::Path<'static>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Station",
            "ConnectedNetwork",
        )
    }

    fn scanning(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "net.connman.iwd.Station", "Scanning")
    }

    fn state(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "net.connman.iwd.Station", "State")
    }
}

pub trait NetConnmanIwdWiFiSimpleConfiguration {
    fn push_button(&self) -> nonblock::MethodReply<()>;
    fn generate_pin(&self) -> nonblock::MethodReply<String>;
    fn start_pin(&self, pin: &str) -> nonblock::MethodReply<()>;
    fn cancel(&self) -> nonblock::MethodReply<()>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> NetConnmanIwdWiFiSimpleConfiguration
    for nonblock::Proxy<'a, C>
{
    fn push_button(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.WiFiSimpleConfiguration", "PushButton", ())
    }

    fn generate_pin(&self) -> nonblock::MethodReply<String> {
        self.method_call("net.connman.iwd.WiFiSimpleConfiguration", "GeneratePin", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn start_pin(&self, pin: &str) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.WiFiSimpleConfiguration", "StartPin", (pin,))
    }

    fn cancel(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.WiFiSimpleConfiguration", "Cancel", ())
    }
}

pub trait NetConnmanIwdAccessPoint {
    fn start(&self, ssid: &str, wpa2_psk: &str) -> nonblock::MethodReply<()>;
    fn stop(&self) -> nonblock::MethodReply<()>;
    fn started(&self) -> nonblock::MethodReply<bool>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> NetConnmanIwdAccessPoint
    for nonblock::Proxy<'a, C>
{
    fn start(&self, ssid: &str, wpa2_psk: &str) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.AccessPoint", "Start", (ssid, wpa2_psk))
    }

    fn stop(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.AccessPoint", "Stop", ())
    }

    fn started(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.AccessPoint",
            "Started",
        )
    }
}
